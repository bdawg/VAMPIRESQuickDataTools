<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>VAMPIRES_Data_Description</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>

<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>


</head>

<body>

<h1 id="toc_0">VAMPIRES Data and Tools Description</h1>

<p><em>Version 0.1, October 2016</em></p>

<p>Contact: Barnaby Norris - <a href="mailto:barnaby.norris@sydney.edu.au">barnaby.norris@sydney.edu.au</a></p>

<h2 id="toc_1">Contents</h2>

<ul>
<li><a href="#sec_PolzDiffCal">Polarisation-differential calibration</a>

<ul>
<li><a href="#sec_PolzDiffCal_FileDesc">File description</a></li>
<li><a href="#sec_PolzDiffCal_FormatDesPython">Data format description &amp; python tools</a></li>
<li><a href="#sec_PA">Position angle offsets</a></li>
</ul></li>
<li><a href="#sec_NonpolzCal">Conventional non-polarised calibration</a>

<ul>
<li><a href="#sec_NonpolzCal_FileDesc">File description</a></li>
<li><a href="#sec_NonpolzCal_FormatDesPython">Data format description &amp; python tools</a></li>
</ul></li>
</ul>

<h2 id="toc_2">Overview</h2>

<p>VAMPIRES data products are still in the form of IDL save files, as its aperture-masking data is initially reduced using the IDL aperture-masking pipeline. IDL is becoming uncommon, so a set of Python tools to read and perform basic tasks with this data is being developed. The Python tools are however in a very early stage of development!!</p>

<p>VAMPIRES allows two distinct calibration modes, leading to two distinct data product formats:</p>

<ul>
<li><strong>Polarisation-differential calibration</strong> - This is the main mode VAMPIRES is designed for. It calibrates visibilities and closure phases between orthogonal polarisation states using a three-tiered polarisation switching scheme. This gives very good calibration precision (it is quasi-simultaneous).</li>
<li><strong>Conventional non-polarised calibration</strong> - This is just the traditional interferometry approach, where the visibilities and closure phases of the science target are calibrated with those observed from a separate calibrator star. This relies on the PSF being constant between targets, and currently this works less well as the SCExAO PSF seems to vary with time.</li>
</ul>

<p>A description of the calibration scheme can be found in <a href="http://adsabs.harvard.edu/abs/2015MNRAS.447.2894N">Norris, et al. (2015), MNRAS 447 3</a></p>

<p><a name="sec_PolzDiffCal"></a></p>

<h2 id="toc_3">Polarisation-differential calibration</h2>

<p><a name="sec_PolzDiffCal_FileDesc"></a></p>

<h3 id="toc_4">File description</h3>

<p>The data products of the differential calibration are stored in IDL save files with the naming format</p>

<div><pre><code class="language-none">diffdata_[target name]_[description string]_[calmode].idlvar</code></pre></div>

<p>or, if it has been split into PA bins,</p>

<div><pre><code class="language-none">diffdata_[target name]_[description string]_PABinNum[num]_[PA Range]_[calmode].idlvar</code></pre></div>

<p><code>[calmode]</code> refers to the number and combination of tiers used in the differential calibration.   By default, data products with several different calibration modes are produced for diagnostic purposes. <strong>Mode 0 refers to the full 3-tiered calibration, and you should always use this unless you&#39;re doing something special!</strong> The calmode number is defined as follows:</p>

<ul>
<li>0 - Triple calibration. <strong>Use this unless you have some special reason to do otherwise!</strong></li>
<li>1 - Double calibration, just use beamsplitter and LCVR</li>
<li>2 - Double calibration, just use beamsplitter and half-wave plate</li>
<li>3 - Double calibration, just use LCVR and half-wave plate</li>
<li>4 - Single calibration, just use beamsplitter</li>
<li>5 - Single calibration, just use LCVR</li>
<li>6 - Single calibration, just use half-wave plate</li>
</ul>

<p>Following the number (except in the case of 0) is a letter, which specifies which of the possible combinations of that calmode are used. E.g. <code>2a</code> would calibrate using the beamsplitter and LCVR, using only data from half-wave plate position 0, while <code>2b</code> would calibrate using the beamsplitter and LCVR, using only data from half-wave plate position 1. Usually only the <code>a</code> file is saved.</p>

<p>Since the differential visibility data cannot simply be derotated and added (since this would also rotate the axis of the polarisation analyser with respect to the target), calibrated data is also saved into bins of position-angle (PA), to allow simultaneous model fitting to all of them. In these cases a bin number and range of PA in degrees <code>[PA Range]</code> is included in the filename.</p>

<p>In addition to the <code>diffdata*</code> files, a large collection of metadata is saved in an IDL save file with the naming format</p>

<div><pre><code class="language-none">cubeinfo[id string].idlvar</code></pre></div>

<p>Both sets of files can be parsed using the Python tools described subsequently...</p>

<p><a name="sec_PA"></a>   </p>

<h3 id="toc_5">Position angle offsets</h3>

<p>The VAMPIRES software queries the Gen2 telescope control system upon acquiring each datacube, and records the relevant keyword/value pairs associated with the telescope pointing and image rotator. The VAMPIRES data reduction software then uses these values to derive a sky position angle. The simplest method to determine this angle is by using the IMR.PAD keyword (saved as <em>PA</em> in the Python tools), which is calculated by Gen2 as a function of the parallactic angle and the image-rotator angle.</p>

<p>However there remains a constant offset due to the various out-of-plane optics in SCExAO. Then PA_Sky, the position angle with respect to sky north, measured in degrees east of north, is given by</p>

<div><pre><code class="language-none">PA_Sky = PA_Obs + IMR.PAD + offset</code></pre></div>

<p>where PA_Obs is the position angle observed with respect to VAMPIRES’ detector-up direction (where pixel (0,0) is at the bottom-left).</p>

<p>As of Q1 2016 the offset is measured to be</p>

<div><pre><code class="language-none">offset = 54 +/- 4 degrees</code></pre></div>

<p><a name="sec_PolzDiffCal_FormatDesPython"></a></p>

<h3 id="toc_6">Data format description and Python tools</h3>

<p>The simplest way to access the differential data is using <code>readDiffdata.py</code> and the <code>vampDiffdata</code> class therein. </p>

<p>A data object can be returned by doing</p>

<div><pre><code class="language-none">diffData = vampDiffdata(dataFilename, cubeInfoFilename)</code></pre></div>

<p>where   <code>dataFilename</code> is the <code>diffdata_*.idlvar</code> file. This will return an object with the following attributes:</p>

<div><pre><code class="language-none">.vhhv       - polarised differential visibilities for instrument Stokes Q
.vhhverr    - 1-sigma errors for polarised differential visibilities for instrument Stokes Q
.vhhvu      - polarised differential visibilities for instrument Stokes U
.vhhvuerr   - 1-sigma errors for polarised differential visibilities for instrument Stokes U
.diffCP     - polarised differential closure-phases for instrument Stokes Q
.diffCPerr  - 1-sigma errors for polarised differential closure-phases for instrument Stokes Q
.diffCPu    - polarised differential closure-phases for instrument Stokes U
.diffCPuerr - 1-sigma errors for polarised differential closure-phases for instrument Stokes U
.blengths   - baseline lengths
.bazims     - baseline azimuths (in instrument coords)
.u_coords   - u coordinates (in instrument coords)
.v_coords   - v coordinates (in instrument coords)</code></pre></div>

<p>It also contains geometry data...</p>

<div><pre><code class="language-none">.BL2H_IX     - The &#39;baseline-to-hole indices&#39;. A (numBLs x 2) array which specifies the pair of 
                hole numbers corresponding to each baseline. I.e., given a baseline, bl2h_ix 
                gives the 2 holes that go to make it up
.H2BL_IX     - The &#39;hole-to-baseline indices&#39;. An (numHoles x numHoles) array which baselines 
                correspond to any pair of holes. I.e., given a pair of holes i,j H2BL_IX[i,j] 
                gives the number of the baseline
.BS2BL_IX    - The &#39;bispectrum-to-baseline&#39; indices. Relates bispectrum/closure phase triangle 
                indices to baselines. I.e., given a point in the bispectrum, BS2BL_IX gives the 
                3 baselines which make the triangle.
.BL2BS_IX    - The &#39;baseline-to-bispectrum indexes&#39;. BL2BS_IX gives the index of all points in 
                the bispectrum containing a given baseline
.FILTER      - 2-element array giving the centre wavelength and bandpass of the filter
</code></pre></div>

<p>and some metadata:</p>

<div><pre><code class="language-none">.UTCs        - UTC times for each observation
.ras, .decs  - telescope RA and dec for each observation
.mask        - name of aperture mask used
.emgains     - EM gain of camera for each observation
.mffile      - the name of the matched-filter file used in data reduction. This file contains
                information on u,v sampling, correspondence of closure phase triangles to 
                baselines, etc.
.pkflux      - peak flux in frame for each observation
.totflux     - total flux in frame for each observation</code></pre></div>

<p>The class also includes methods to make simple plots of differential visibilities - <code>.plotVHVVdata()</code> - and closure phases - <code>.plotDiffCPdata()</code>. An example usage would be</p>

<div><pre><code class="language-python">diffData = vampDiffdata(srcFilename, srcCubeInfoFilename)
diffData.plotVHVVdata()
diffData.plotDiffCPdata(figNum=2)
plt.show()</code></pre></div>

<p>Additionally, a GUI tool (<em>vampCrawler</em>) is being developed to allow quick browsing and examination of reduced data, as described later in these notes.</p>

<p><a name="sec_NonpolzCal"></a></p>

<h2 id="toc_7">Conventional non-polarised calibration</h2>

<p>While the polarisation-differential data has already been calibrated, this is not the case for conventional calibration since there is not necessarily one &#39;correct&#39; way to do it. To this end, the <em>vampCalNP.py</em> Python tool is being developed. This will perform visibility and closure-phase calibration between specified data sets and sub-sets. It will also provide various plotting functions. It is still in development but useful basic features are available. </p>

<p>Performing conventional calibration of VAMPIRES data is complicated by the fact that there are 16 polarisation-switching states (4 halfwave-plate positions x 2 beam-splitter channels x 2 LCVR states). Each of these stats has a slightly different PSF due to spatially-dependent instrumental polarisation (such as curved mirrors or inconsistent coatings on optical surfaces) and, in the case of the beamsplitter channel, non-common path errors. Therefore best performance should be found by <strong>calibrating data of each of these states against the corresponding state of the calibrator data</strong>.</p>

<p><a name="sec_NonpolzCal_FileDesc"></a></p>

<h3 id="toc_8">File description</h3>

<p>The raw visibilities and closure-phases produced by the data-reduction pipeline are stored in a set of IDL save files with the naming format</p>

<div><pre><code class="language-none">bs_[target name]_[description string]_[serial number]_[chan]_[lcvr].idlvar</code></pre></div>

<p>where <code>[serial number]</code> corresponds to the file number of the original data (usually starting at 0 and counting up), <code>[chan]</code> is the beamsplitter channel, labelled as &#39;1&#39; or &#39;2&#39; and <code>[lcvr]</code> is the LCVR state, labelled as &#39;A&#39; or &#39;B&#39;. Data must be in the standard VAMPIRES acquisition sequence, i.e. the first file is HWP=0, the second file is HWP=22.5, then 45, then 67.5, then back to 0. Each file must have <code>_1_A</code>, <code>_1_B</code>, <code>_2_A</code> and <code>_2_B</code> variants.</p>

<p>The <code>cubeinfo</code> file described above is also used.</p>

<p><a name="sec_NonpolzCal_FormatDesPython"></a></p>

<h3 id="toc_9">Data format description and Python tools</h3>

<p><code>vampCalNP.py</code> consists of a set of functions used to calibrate the data and plot it in various ways. The accompanying script <code>doCalScript.py</code> gives some how-to examples.</p>

<p>To read in a set of data, several parameters must be specified:</p>

<ul>
<li><em>srcPath</em> - path to the data files</li>
<li><em>srcPrefix</em> - the part of the date filename before the serial number, e.g. <code>bs_vega_18hNCombined_20160101_750-50_18holeNudged_</code></li>
<li><em>srcStartNum</em> - first file number to use. = 0 if you want the whole set.</li>
<li><em>numSrc</em> - the number of data files to read in. This must be a multiple of 4 (i.e. includes equal numbers of all HWP positions)</li>
<li><em>srcExtn</em> - usually this is <code>.idlvar</code></li>
<li><em>rootDir</em> - the directory containing the <em>templates</em> directory if using the full IDL pipeline. Otherwise, this should be <code>./</code> and the <em>templates</em> directory placed in the working folder.</li>
<li><em>srcCubeInfoFilename</em> - the filename of the <em>cubeinfo</em> file, as described earlier.</li>
</ul>

<p>A set of data can then be read into a data object as follows:</p>

<div><pre><code class="language-python">import vampCalNP as vc
...
sciData = vc.readDataSet(srcPath, srcPrefix, srcStartNum, numSrc, srcExtn, rootDir, 
                srcCubeInfoFilename)</code></pre></div>

<p>This returns an object containing the entire data set. It is a list object with one entry for each dataset (so 4x the number of input files due to 4 polarisation states per file)
Each dataset has the following attributes:</p>

<div><pre><code class="language-none">.u_coords, .v_coords    - arrays of uv coordinates for that baseline
.vis2                   - array of squared visibilities
.vis2Err                - array of 1-sigma visibilty errors (NB covariance is not yet taken 
                            into account!)
.cp                     - array of closure phases
.cpErr                  - array of 1-sigma closure phase errors (NB covariance is not yet 
                            taken into account!)
.pa                     - *relative* position-angle for this data (see Position Angle 
                            Offsets section)
.mfFilename             - the name of the matched-filter file used in data reduction. 
                            This file contains information on (u,v) sampling, correspondence 
                            of closure phase triangles to baselines, etc.
.hwpMode                - Integer specifying the half-wave plate state for this data, as 
                            per the following:
                            0 = 0 degrees; 1 = 22.5 degrees; 2 = 45 degrees; 3 = 67.5 degrees
.chanMode               - Integer specifying the polarising beamsplitter channel for this 
                            data (0 or 1)
.lcvrMode               - Integer specifying the LCVR state for this data (0 or 1)</code></pre></div>

<p>It also contains an object called <code>mfFileData</code>, which contains metadata regarding the physical geometry of the mask, used, for example, to work out which closure phases correspond to which baselines, etc. It has these attributes:</p>

<div><pre><code class="language-none">.mfFileData.u
.mfFileData.v           - The u,v coordinates for each baseline
.mfFileData.BL2H_IX     - The &#39;baseline-to-hole indices&#39;. A (numBLs x 2) array which 
                            specifies the pair of hole numbers corresponding to each baseline.
                            I.e., given a baseline, BL2H_IX gives the 2 holes that go to 
                            make it up
.mfFileData.H2BL_IX     - The &#39;hole-to-baseline indices&#39;. An (numHoles x numHoles) array 
                            which specifies baselines correspond to any pair of holes.
                            I.e., given a pair of holes i,j H2BL_IX[i,j] gives the number 
                            of the baseline
.mfFileData.BS2BL_IX    - The &#39;bispectrum-to-baseline&#39; indices. Relates bispectrum / 
                            closure phase triangle indices to baselines. I.e., given a point 
                            in the bispectrum, BS2BL_IX gives the 3 baselines which make the 
                            triangle.
.mfFileData.BL2BS_IX    - The &#39;baseline-to-bispectrum indexes&#39;. BL2BS_IX gives the index 
                            of all points in the bispectrum containing a given baseline
.mfFileData.FILTER      - 2-element array giving the centre wavelength and bandpass of 
                            the filter</code></pre></div>

<p>See the various examples in `<code>doCalScript.py</code> for some details on the various tools available. But for a quick starting point, a simple calibration might go like this:</p>

<div><pre><code class="language-python">import vampCalNP as vc

# Read in data
sciData = vc.readDataSet(srcPath, srcPrefix, srcStartNum, numSrc, srcExtn, rootDir, srcCubeInfoFilename)
calData = vc.readDataSet(calPath, calPrefix, calStartNum, numCal, calExtn, rootDir, calCubeInfoFilename)

# Do basic calibration:
# Combine all calibrator data but keep it in its 16 polarisation states
calDataCombinedSepStates = vc.combineDataSeparated(calData)

# Make set of all science data calibrated against the matching calibrator polz states
calibratedDataSepStatesAll = vc.calibrateSeparately(sciData, calDataCombinedSepStates)

# De-rotate the calibrated data as per its PA
calibratedDataSepStatesAllDerot = vc.derotate(calibratedDataSepStatesAll)

# Make a plot of the calibrated data (only do this if you have ~10 input files, or graph
# gets too slow and cluttered)
vc.plotData.plotByPolzstate(calibratedDataSepStatesAllDerot, xlims=[0, 1.2e7], 
    ylims=[0,2], alpha = 0.1, figNum=1)
    
# Or make a 2D plot of the visibilities from just the first file:
vc.plotData.plot2DSingleVis2(calibratedDataSepStatesAllDerot, interpolate=True, figNum=2)
    
# Plot histogram of closure phases of calibrated data,
# keeping 16 polarisation states separate
vc.plotData.plotCPByPolzstate(calibratedDataSepStatesAllDerot, alpha=0.1, figNum=3)</code></pre></div>

<p><strong><em>vampCalNP does not yet have OIFITS support</em></strong> - this is the next thing to be implemented. For now, once data is read into Python objects it can be saved into a generic format or manipulated as desired.</p>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.python={"triple-quoted-string":{pattern:/"""[\s\S]+?"""|'''[\s\S]+?'''/,alias:"string"},comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:/("|')(?:\\?.)*?\1/,"function":{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)[a-z0-9_]+/i,lookbehind:!0},keyword:/\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,"boolean":/\b(?:True|False)\b/,number:/\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,operator:/[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,punctuation:/[{}[\];(),.:]/};
</script>


</body>

</html>
